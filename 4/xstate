#! /usr/bin/env racket
#lang racket

(require json)

(require "../Maze/Common/serialize.rkt")
(require "../Maze/Common/board.rkt")
(require "../Maze/Common/state.rkt")


;; InputPort -> (values HashTable HashTable)
;; Reads a board object and coordinate object from STDIN
(define (read-json-input input-port)
  (define state-ht (read-json input-port))
  (define index-ht (read-json input-port))
  (define dir-ht (read-json input-port))
  (define degree-ht (read-json input-port))
  (values state-ht index-ht dir-ht degree-ht))


;; GridPosn GridPosn -> Boolean
;; Compares two GridPosns in row-then-column order
(define (compare-row-col pos1 pos2)
  (define-values (row1 col1 row2 col2) (values (car pos1) (cdr pos1) (car pos2) (cdr pos2)))
  (cond
    [(= row1 row2) (<= col1 col2)]
    [(< row1 row2) #t]
    [(> row1 row2) #f]))

(module+ test
  (require rackunit)
  (check-true (compare-row-col (cons 0 0) (cons 0 0)))
  (check-true (compare-row-col (cons 0 0) (cons 0 1)))
  (check-false (compare-row-col (cons 0 1) (cons 0 0)))
  (check-false (compare-row-col (cons 1 0) (cons 0 1))))


;; Reads a board and position from STDIN, computes all positions reachable from
;; the given position, and writes these positions to STDOUT as JSON
(module+ main
  (define-values (state-ht index-ip dir-ip degree-ip) (read-json-input (current-input-port)))
  (define state (hash->gamestate state-ht))
  (define index index-ip)
  (define dir (string-direction->symbol dir-ip))
  (define degree degree-ip)
  (define state-after-shift (gamestate-shift-and-insert state dir index degree))

  (write-json
   (map gridposn->hash (sort (all-reachable-from-active state-after-shift) compare-row-col))))